use strict;
use warnings;
use Cwd qw[cwd];
use IPC::Cmd qw[can_run run];
use File::Find qw[find];
use File::Spec::Functions qw[
  catdir splitpath splitdir catpath rel2abs abs2rel catfile
];
use B qw[perlstring];
use Log::Message::Simple qw[msg error];
use Getopt::Long;

my $VERBOSE = 0;
my $STRIP   = 0;

GetOptions (
  "strip"    => \$STRIP,
  "verbose"  => \$VERBOSE,
)
or die("Error in command line arguments\n");

my $filter;

if ( $STRIP ) {
  require Perl::Strip;
  $filter = sub {
    my ($data) = @_;
    return Perl::Strip->new( keep_nl => 0, optimise_size => 0, )->strip($data);
  };
}
else {
  $filter = sub {
    return shift;
  };
}

#my $diff = catfile( qw[dev-bin Module-Pluggable.patch] );
#my $meep = catfile( qw[inc bundle Module Pluggable Object.pm] );

$|=1;

#patch_mpo();

msg("Generating 'cpanp-fat'", $VERBOSE);
open my $fat, '>', 'cpanp-fat' or die "$!\n";
my $fatpacked = '#!/usr/bin/env perl' . "\n" . fatpack_files() . open_cpanp();
print {$fat} $fatpacked;
close $fat;
msg("Generated 'cpanp-fat'", 1);
#run( command => [ 'git', 'checkout', 'inc/bundle/Module/Pluggable/Object.pm' ], verbose => 1 );
exit 0;

sub open_cpanp {
  msg("Slurping 'bin/cpanp'", $VERBOSE);
  my $cpanp = do {
    open my $CPANP, '<', 'bin/cpanp' or die "Doh $!\n";
    local $/;
    <$CPANP>
  };
  $cpanp =~ s|#!/usr/bin/perl||;
  return $cpanp;
}

sub stripspace {
  my ($text) = @_;
  $text =~ /^(\s+)/ && $text =~ s/^$1//mg;
  $text;
}

sub fatpack_files {
  my $cwd = cwd;
  my @dirs = map rel2abs($_, $cwd), ('lib','inc/bundle');
  my %files;
  foreach my $dir (@dirs) {
    find(sub {
      return unless -f $_;
      !/\.pm$/ and error("File ${File::Find::name} isn't a .pm file",$VERBOSE)
         and return;
      msg("Found '$File::Find::name'", $VERBOSE);
      $files{abs2rel($File::Find::name,$dir)} = do {
        local (@ARGV, $/) = ($File::Find::name); <>
      };
    }, $dir);
  }
  my $start = stripspace <<'  END_START';
    # This chunk of stuff was generated by App::FatPacker. To find the original
    # file's code, look for the end of this BEGIN block or the string 'FATPACK'
    BEGIN {
    my %fatpacked;
  END_START
  my $end = stripspace <<'  END_END';
    s/^  //mg for values %fatpacked;

    my $class = 'FatPacked::'.(0+\%fatpacked);
    no strict 'refs';
    *{"${class}::files"} = sub { keys %{$_[0]} };

    if ($] < 5.008) {
      *{"${class}::INC"} = sub {
         if (my $fat = $_[0]{$_[1]}) {
           return sub {
             return 0 unless length $fat;
             $fat =~ s/^([^\n]*\n?)//;
             $_ = $1;
             return 1;
           };
         }
         return;
      };
    }

    else {
      *{"${class}::INC"} = sub {
        if (my $fat = $_[0]{$_[1]}) {
          open my $fh, '<', \$fat
            or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
          return $fh;
        }
        return;
      };
    }

    unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE
  END_END
  my @segments = map {
    (my $stub = $_) =~ s/\.pm$//;
    my $name = uc join '_', split '/', $stub;
    my $data = $files{$_};
    $data = $filter->( $data );
    $data =~ s/^/  /mg; $data =~ s/(?<!\n)\z/\n/;
    '$fatpacked{'.perlstring($_).qq!} = <<'${name}';\n!
    .qq!${data}${name}\n!;
  } sort keys %files;
  return join "\n", $start, @segments, $end;
}

#sub patch_mpo {
#  my $git_exe = can_run('git') || die "No 'git' utility found, giving up\n";
#  die unless scalar run( command => [ $git_exe, 'apply', $diff ], verbose => 1 );
#}
