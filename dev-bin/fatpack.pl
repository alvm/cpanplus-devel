use strict;
use warnings;
use Cwd qw[cwd];
use IPC::Cmd qw[can_run run];
use File::Find qw[find];
use File::Spec::Functions qw[
  catdir splitpath splitdir catpath rel2abs abs2rel catfile
];
use B qw[perlstring];
use Log::Message::Simple qw[msg error];

my $VERBOSE = shift;

my $diff = catfile( qw[dev-bin Module-Pluggable.patch] );
my $meep = catfile( qw[inc bundle Module Pluggable Object.pm] );

$|=1;

patch_mpo();

msg("Generating 'cpanp-fat'", $VERBOSE);
open my $fat, '>', 'cpanp-fat' or die "$!\n";
my $fatpacked = '#!/usr/bin/env perl' . "\n" . fatpack_files() . open_cpanp();
print {$fat} $fatpacked;
close $fat;
msg("Generated 'cpanp-fat'", 1);
exit 0;

sub open_cpanp {
  msg("Slurping 'bin/cpanp'", $VERBOSE);
  my $cpanp = do {
    open my $CPANP, '<', 'bin/cpanp' or die "Doh $!\n";
    local $/;
    <$CPANP>
  };
  $cpanp =~ s|#!/usr/bin/perl||;
  return $cpanp;
}

sub stripspace {
  my ($text) = @_;
  $text =~ /^(\s+)/ && $text =~ s/^$1//mg;
  $text;
}

sub fatpack_files {
  my $cwd = cwd;
  my @dirs = map rel2abs($_, $cwd), ('lib','inc/bundle');
  my %files;
  foreach my $dir (@dirs) {
    find(sub {
      return unless -f $_;
      !/\.pm$/ and error("File ${File::Find::name} isn't a .pm file",$VERBOSE)
         and return;
      msg("Found '$File::Find::name'", $VERBOSE);
      $files{abs2rel($File::Find::name,$dir)} = do {
        local (@ARGV, $/) = ($File::Find::name); <>
      };
    }, $dir);
  }
  my $start = stripspace <<'  END_START';
    # This chunk of stuff was generated by App::FatPacker. To find the original
    # file's code, look for the end of this BEGIN block or the string 'FATPACK'
    BEGIN {
    my %fatpacked;
  END_START
  my $end = stripspace <<'  END_END';
    s/^  //mg for values %fatpacked;

    my $i = 0;
    unshift @INC, sub {
      if ( $_[1] eq 'FatPacked/Internals.pm' ) {
        my $fatfile = "/tmp/fat_pack_" . $i;
        $i++;
        open my $wfh, '>', $fatfile or die "Error opening file";
        my $internals = "package FatPacked::Internals;\n\nuse strict;\nuse warnings;\n";
        $internals .= "sub fatpacked {\nreturn (\n";
        $internals .= join "\n", map { "'$_'," } sort keys %fatpacked;
        $internals .= "); }\n\n1;\n";
        print { $wfh } $internals;
        close $wfh;
        open my $fh, '<', $fatfile;
        unlink $fatfile;
        return $fh;
      }
      if (my $fat = $fatpacked{$_[1]}) {
        my $fatfile = "/tmp/fat_pack_" . $i;
        $i++;
        open my $wfh, '>', $fatfile or die "Error opening file";
        print { $wfh } $fat;
        close $wfh;
        open my $fh, '<', $fatfile;
        unlink $fatfile;
        return $fh;
      }
      return
    };

    } # END OF FATPACK CODE
  END_END
  my @segments = map {
    (my $stub = $_) =~ s/\.pm$//;
    my $name = uc join '_', split '/', $stub;
    my $data = $files{$_}; $data =~ s/^/  /mg; $data =~ s/(?<!\n)\z/\n/;
    '$fatpacked{'.perlstring($_).qq!} = <<'${name}';\n!
    .qq!${data}${name}\n!;
  } sort keys %files;
  return join "\n", $start, @segments, $end;
}

sub patch_mpo {
  my $git_exe = can_run('git') || die "No 'git' utility found, giving up\n";
  die unless scalar run( command => [ $git_exe, 'apply', $diff ], verbose => 1 );
}
